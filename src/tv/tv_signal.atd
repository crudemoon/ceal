(*
  Matthew Hammer <hammer@mpi-sws.org>
  
  TV SIGNALS = Trace Visualization Signals
  
  We define them here using so-called "adjustable data types", i.e.,
  as ML data types.  A tool uses this file to automatically generate
  Caml code that can serialize/deserialize them to/from JSON.  Our
  CEAL compiler (written in Caml) produces C code which itself
  produces this JSON format using a runtime (written in C).

  FILES :
  - - - - 

  ./src/tv/tv_signal.atd ---- This file.  It is the "main" file for tv
  signals.  It gives them as "adjustable type definitions" (ATDs).

  tv_signal.mli,.ml ---- Generated by atdgen from tv_signal.atd.  It
  defines tv signals as Caml types.  It can serialize and deserialze
  them.  We use these files to write various tools in Caml.  See the
  "phases" described below.
  
  ./src/cilext/cealc.ml ---- Instruments CEAL programs with C code to
  generate tv signals using the runtime library, see ./src/lib/runtime.

  ./src/lib/runtime/tv_signal.[hc] ---- Generates tv signals in a file
  when CEAL meta+core programs run, see "ceal.tv" in the working directory.

  ceal.tv ----  that contains tv signals as meta+core programs run.

  - - - - -   - - - - -   - - - - -   - - - - -   - - - - -   - - - - - 

  So? Then what? . . .
  - - - - - - - - - - -
  
  Phase 1: The runtime produces TV signals with most, if not all the
  data present (e.g., our compiler currently messes up the program
  point information; a fix will take a little tedious work).

  Phase 2: tv_dump tool
  
  -- Part a: generate simple, human-readable "skeleton" traces that
  only contain function calls, using indentation to indicate stack
  depth.  The traces indicate evaluation steps during from-scratch
  runs and change-propagation.  Arthur asked for this.
  
  -- Part b: generate full, human-readable traces that contain all
  available information, but in a way that can be filtered using
  various queries.  The query-based filtering should be a resuable
  artifact.

  Phase 3: tv_watch tool

  -- Part a: maintain persistent copies of the trace using tv signals.
  Each copy reflects which actions are in the trace at some point in
  the tv signal stream.  When actions are invoked, they are added to
  the next copy.  When actions are revoked, they are removed from the
  next copy. Intially, the display function maps the maintained copy
  to a text i/o channel.  This text uses various filtering options
  (see Phase 2 above).
  
  -- Part b: the copy is sent to a MLpost-based renderer, which itself
  can produce a variety of image formats.

  Phase 4: tv_dvr tool
  
  -- A full-blown GUI with DVR controls and a movable focus.
  Extensive filtering / query options.

  - - - - -   - - - - -   - - - - -   - - - - -   - - - - -   - - - - - 
  
  Static versus dynamic information: 
  - - - - - - - - - - - - - - - - - -
  For now, we do not separate static and dynamic elements.  For
  instance, we know all C program points a priori (at compile-time),
  yet we send them (and resend them) dynamically for each signal.
*)

(* 
   - - - - - - - - -
   Program points. 
   - - - - - - - - -
*)

type ppt_id = int

(* Caching program points. (supported in future versions?). *)
type ppt = { 
  ppt_id    : ppt_id ;
  ppt_file  : string ;
  ppt_fname : string ;
  ppt_line  : int ;
  ppt_byte  : int ;
}

(*
  - - - - - - - - - - - - - - - - - - - - 
  C components, both dynamic and static 
  - - - - - - - - - - - - - - - - - - - - 
*)  

type c_var  = string (* variable *)
type c_typ  = string (* type *)
type c_qual = string (* qualifier *)
type c_fun  = string (* function *)

type c_val  = string (* (scalar) value *)
type c_ptr  = string (* pointer, as encoded by printf("%p",ptr). *)
type c_sz   = int    (* size *)

type c_env  = (c_var * c_val * c_typ) list (* dynamic environment *)
type c_vals = (c_val * c_typ) list         (* arguments/returns *)

(* 
   - - - - - - - - - - - - - - - - - - - - -
   Trace components, both dynamic and static
   - - - - - - - - - - - - - - - - - - - - -
*)

(* Action descriptors.  See {!action}. *)
type action_desc =
    [ A_alloc  of (c_typ * c_sz * c_ptr)
    | A_scope  of c_ptr
    | A_read   of (c_qual * c_typ * c_ptr * c_val)
    | A_write  of (c_qual * c_typ * c_ptr * c_val)
    | A_update of c_env
    | A_memo   of c_env
    | A_tcall  of (c_fun * c_vals) (* for debugging; not for replay *)
    | A_pop    of c_vals           (* for debugging; not for replay *)
    | A_push_begin                 (* for debugging; not for replay *)
    | A_push_end                   (* for debugging; not for replay *)
    | A_end  (* -- "ends", here represented as an "action", are shared
                amongst many nested intervals.  This action form isn't
                needed in the tracing machine, but it is helpful in
                the RT implementation. *)
    ]

(* A unique id for actions.  The first pointer, call it {!trnode}, is
   shared among (one or more) actions that all change state as a unit.
   Before actions with {!trnode} are invoked, {!trnode} should be
   {!D_allocated}. The second pointer, call it {!handle}, is unique. *)
type trnode_id = c_ptr
type action_id = (trnode_id * c_ptr)
    
(* trace of from-scratch step of core program / 
   trace of reference-machine step. *)
type action = (ppt * action_id * c_sz * action_desc)

(* trace of (a tracing machine step) *)
type step =
    [ S_invoke of action    (* eval step. *)
    | S_revinv of action    (* undo step; eval step. Same action_id. action_desc may differ. *)
    | S_revoke of action_id (* undo step. *)
    | S_reuse  of trnode_id (* eval --> prop @ memo, i.e., E.P step. *)
    | S_propto of trnode_id (* prop --> prop, over consistent actions. *)
    | S_redo   of trnode_id (* prop --> eval @ update, i.e., P.E step. *)
    ]

(* meta-level steps on the tracing machine. *)
type meta_desc =
    [ M_core_begin
    | M_core_end
    | M_prop_begin
    | M_prop_end
    | M_alloc of (c_typ * c_sz * c_ptr)
    | M_kill  of c_ptr
    | M_write of (c_qual * c_typ * c_ptr * c_val)
    | M_read  of (c_qual * c_typ * c_ptr * c_val)
    ]

type meta = (ppt * meta_desc)


(* declaration about RT state. See {!event}. *)
type decl =
    [ D_allocated  of (trnode_id * c_typ * c_sz) (* next state: either freed or consistent *)
    | D_consistent of trnode_id (* state = alive and consistent; has active timestamp. *)
    | D_enqueued   of trnode_id (* trace might be inconsistent. next state: dequeued. *)
    | D_dequeued   of trnode_id (* next state: either consistent or collected / freed. *)
    | D_collected  of trnode_id (* no longer in use; will be free-able eventually. *)
    | D_freed      of trnode_id (* all incoming references are gone. *)
    ]

(* trace of (some RT-based implementation of (a tracing machine)) *)
type event =
    [ (* these are emitted by RT calls, inserted into target code by cealc. *)
      E_step of step (* a step of tracing machine. *)
        
    (* these are emmitted by RT calls, from within the RT itself. *)
    | E_decl of decl (* a declaration / assertion about run-time system state. *)
        
    (* these are eimitted by RT calls, inserted into the target code
       by cealc as well as the RT itself. *)
    | E_meta of meta (* a meta-level step on the tracing machine. *)
 
    ]

